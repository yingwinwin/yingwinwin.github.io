---
id: cs_net
title: 计算机网络
---

## 输入url到页面渲染发生了什么？

### 用户输入
1. 如果输入的是内容：直接又浏览器引擎进行搜索
2. 如果输入的是url：浏览器通过补全协议
3. 用户在回车后，还会触发`beforeload`方法，就是在离开当前页面前的生命周期，如果正常跳转进入下一步
### url请求
1. 是否有缓存，如果有`缓存`进行缓存读取，然后请求结束
2. 如果没有缓存，进行`DNS`解析，`TLS`连接，然后进行`TCP`连接（如果TCP连接过多，需要等待队列）
3. 返回响应头解析：先解析`状态码`，如果是`301/302`那么进行重定向操作，会从location字段中取出内容进行重新跳转
4. 然后解析`文档类型`：如果是`Content-Type` 的值是 `application/octet-stream`，显示数据是字节流类型的进行下载，导航流程结束。如果是html继续进行下面的流程。
### 准备渲染进程
1. 默认是`同一站点`使用一个渲染进程，如果`Referrer Policy`的字段是不使用同一渲染进程就不会使用同一个渲染进程
2. 如果不是同一站点，准备一个`新的渲染进程`。准备好了之后告诉浏览器进程，我准备好了，接着开始进行渲染进程的内容。
### 提交文档
1. 渲染进程接受完来自网络进程的数据之后，给浏览器进程一个确认提交的消息
2. 浏览器离开老页面，清空老页面的页面和状态
### 渲染阶段
1. 构建 DOM 树，浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树。
2. 样式计算
    - 要把 CSS 转换为浏览器能够理解的结构`styleSheets`
    - 转换样式表中的`属性值`，使其标准化
    - 然后计算出 DOM 树中每个节点的具体样式
3. 布局阶段，计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局
    - 创建布局树，会忽略display：none的元素
    - 布局计算，计算布局树节点的坐标位置
4. 分层，染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树
    - 拥有层叠上下文属性的元素会被提升为单独的一层 z-index， fliter， position：fixed，opacity
    - 需要剪裁（clip）的地方也会被创建为图层 overfolw：auto
5. 图层绘制，就是图层是出现的过程，像自己画画一样都是有一个画的过程
6. 栅格化操作-将图块转换为位图
    - 绘制好了以后，会交给合成线程，在一个单独的线程，使用GPU加速
    - 合成线程会将图层划分为图块，按照视口的大小生成位图
7. 合成和显示，发送消息给浏览器要浏览器进程展示

## HTTP的几个版本

### HTTP/0.9
- 只有一个请求行，并没有 HTTP 请求头和请求体
- 服务器也没有返回头信息
- 返回的文件内容是以 ASCII 字符流来传输的，因为都是 HTML 格式的文件，所以使用 ASCII 字节码来传输是最合适的

### HTTP/1.0
- 支持多种类型的文件下载
```
请求头
accept: text/html  文件类型
accept-encoding: gzip, deflate, br  文件压缩方式
accept-Charset: ISO-8859-1,utf-8  文件的编码
accept-language: zh-CN,zh  语言

响应头
content-encoding: br   压缩方式
content-type: text/html; charset=UTF-8  类型和编码方式
```
- 处理出错，引入了状态码
- 减轻服务器的压力，引入了`Cache` 机制
- 服务器要统计用不同操作系统的人多少，所以引入了用户代理字段
  
### HTTP/1.1
- 改进持久连接，同一个域名，允许同时建立 6 个 TCP 持久连接
- 持久连接，造成了队头阻塞问题，如果中间卡住了，就会阻塞后面的请求
- 提供虚拟主机的支持，增加了Host 字段，每一个虚拟主机用不同的域名，绑在一个ip上，可以让服务器做不同的处理
- 对动态生成的内容提供了完美支持，Chunk transfer 机制
- CDN 的实现域名分片机制，每一个域名都可以建立6个TCP，所以可以把资源放到不同的cdn服务器，增加连接次数

**HTTP/1.1 的主要问题**
- 对带宽的利用率却并不理想
  - TCP 的慢启动
  - 同时开启了多条 TCP 连接，那么这些连接会竞争固定的带宽
  - HTTP/1.1 队头阻塞的问题

### HTTP/2
- 多路复用（采用了二进制分帧层），一个域名只使用一个 TCP 长连接和消除队头阻塞问题
- 可以设置请求的优先级
- 服务器推送，服务器把数据提前推送到浏览器
- 头部压缩

**HTTP/2的问题**
- TCP 队头阻塞，丢包过多的话，效率更低
- TCP 建立连接的延时，握手过程要2-3个RTT
- TCP 协议僵化，很难改变

### HTTP/3
- QUIC 协议，通过UDP加入中间层QUIC实现传输的稳定，多路复用，加密，快速握手等

## XSS攻击
### 什么是XSS攻击（跨站脚本攻击） 
- 获取cookie信息
- 监听用户行为
- 修改dom
- 生成页面浮窗广告

### XSS攻击的类型
- 存储型攻击，通过存在服务器的脚本，只要用户进入了这个页面就会出发脚本，获取用户当前的cookie或者鼠标行为，发送到黑客的服务器上。
- 反射型攻击，通过发送请求给服务器，服务器同时返回相同的内容，但是如果发送的是脚本，就会造成反射性XSS攻击。
- dom型攻击，通过劫持dom请求，路由器劫持修改dom信息

### 如何避免
- 服务器对输入脚本进行过滤或转码
- 充分利用 CSP，限制js脚本的请求来源
- 使用 HttpOnly 属性，cookie只能用在http请求中，不能被js脚本获取


## CSRF攻击

### 什么是CSRF攻击（跨站请求伪造）
- 黑客引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的跨站请求

### 如何产生
- 自动发起 Get 请求，跨站点get请求
- 自动发起 POST 请求，跨站点post请求
- 引诱用户点击链接
### 防止CSRF攻击
- 充分利用好 Cookie 的 `SameSite` 属性，跨站点情况下，是否可以携带cookie
- 验证请求的来源站点，通过`Referer` 和 `Origin`属性判断是否当前站点的请求
- CSRF Token，进行token验证，没有携带token，不进行反馈